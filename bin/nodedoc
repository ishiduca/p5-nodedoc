#!perl
package MyApp;
use strict;
use warnings;
sub new {
    my $cont = MyApp::Controler->new;
    bless {
        controler => $cont,
        model     => MyApp::Model->new( delete $cont->{argv}{dir} ),
        view      => MyApp::View->new,
    }, shift;
}
1;

package MyApp::Controler;
use strict;
use warnings;
use Smart::Options;
use Cwd          qw(cwd);
use Scalar::Util qw(looks_like_number);
sub new {
    my $class = shift;
    my $argv  = Smart::Options->new
                ->options(
                    h   => { alias   => 'help' },
                    dir => { default => cwd },
                    ls  => { alias   => 'list' },
                    l   => { alias   => 'loc' },
                    p   => { alias   => 'package_json' },
                    r   => { alias   => 'readme' },
                    m   => { alias   => 'module' },
                    lib => { alias   => 'library' },
                )->boolean(qw{
                    help list tree
                })->parse;

    if (defined $argv->{with}) {
        $argv->{with} =~ /^(p|r|m)$/ or
            die qq("with" option must be "p" or "r" or "m");
    }

    if (defined $argv->{_}->[0]) {
        $argv->{readme} = shift @{$argv->{_}};
    }

    delete $argv->{_};

    for my $key (qw/loc package_json readme module library/) {
        if ( defined $argv->{$key}
          && looks_like_number($argv->{$key})
          && $argv->{$key} == 1
        ) {
            die $key eq 'library' ? qq("library" must be relative path)
                                  : qq("$key" must be "module name");
        }
    }

    bless { argv => $argv }, $class;
}

sub test {
    my $self = shift;
    my $cb   = pop;
    unless ( (scalar keys %{ $self->{argv} })             == scalar @_
        &&   (scalar grep{ defined $self->{argv}{$_} }@_) == scalar @_
    ) {
        return;
    }
    $cb->($self->{argv});
    exit 0;
}

1;

package MyApp::Model;
use strict;
use warnings;
use parent qw{ Nodedoc };

1;

package MyApp::View;
use strict;
use warnings;
sub new { bless {}, shift };
sub list {
    my($self, $model, $list_type) = @_;
    my $make_list = $list_type eq 'list' ? 'make_modules_list'
                                         : 'make_modules_tree';
    my $list = $model->$make_list->modules;
    for my $mod_name (sort {uc $a cmp uc $b} keys %{ $list }) {
        my $mod  = $list->{$mod_name};
        my $main = $mod->{main} || "main not found";
        my $version = $mod->{version} || 'version.not.found';
        print qq($mod_name\@$version\t$main\n);
        $self->_loop($mod, 1) if $list_type eq 'tree';
    }
}
sub _loop {
    my($self, $mod, $i) = @_;
    return if ! defined $mod->{dependences};
    for my $child_name (keys %{$mod->{dependences}}) {
        print( "    " x $i . "$child_name\n");
        $self->_loop($mod->{dependences}{$child_name}, $i + 1);
    }
}
sub _resolve_path {
    my($self, $mod, $mode, $opt_library) = @_;
    if ($mode eq 'module') {
        return if ! $mod->{main};
        return $mod->{main};
    }
    if ($mode =~ /^(package_json|readme)$/) {
        if ($mod->{$mode} && $mod->{$mode}{file}) {
            return $mod->{$mode}{file};
        }
        return;
    }
    if ($mode eq 'library' && defined $opt_library) {
        return if ! $mod->{main};
        require File::Basename;
        require Nodedoc;
        return Nodedoc::Find::resolve(
                File::Basename::dirname( $mod->{main} ),
                $opt_library,
        );
    }
}
sub _display {
    my $self = shift;
    my($cb, $model, $mod_name, $mode, $opt_library) = @_;
    $model->find( $mod_name => sub {
        my $mod  = shift;
        if (my $file = $self->_resolve_path( $mod, $mode, $opt_library )) {
            $cb->( $file );
            exit 0;
        }
        die qq("$mod_name" has no "$mode" file);
    });
    die qq("$mod_name" not found);
}
sub display_path {
    my $self = shift;
    unshift @_, sub {print @_};
    $self->_display(@_);
}
sub display_contents {
    my $self = shift;
    if ($_[2] eq 'package_json') {
        $_[0]->find( $_[1] => sub {
            my $mod = shift;
            if ($mod->{package_json}) {
                if (my $data = $mod->{package_json}{data}) {
                    if ($data->{readme}) {
                        $data->{readme} = qq(try `nodedoc -readme $mod->{name}`);
                    }
                    require YAML;
                    print YAML::Dump($data);
                }
                die qq("$_[1]" has no "package.json");
            }
        });
        die qq("$_[1]" not found);
    }

    unshift @_, sub {
        my $file = shift;
        print do {
            local $/;
            open my $fh, '<', $file or die $!;
            <$fh>;
        };
    };

    $self->_display(@_);
}
sub help {
    my($self, $message) = @_;
    if($message) {
        die<<"DYING_MESSAGE";

nodedoc v$Nodedoc::VERSION - display the document of Node.js modules

    error: $message

Show help: nodedoc -h

DYING_MESSAGE
;
    }
    print<<"HELP";

nodedoc v$Nodedoc::VERSION - display the document of Node.js modules

Usage:
    nodedoc -h
    nodedoc [-dir directory] [-ls |
                              -tree |
                              -l module_name [-with option | -lib relative_path] |
                              -p module_name |
                              -r module_name |
                              -m module_name [-lib relative_path]]

Options:
    -h, --help          display help
    -dir                directory that is started to scan
    -ls, --list         dispaly modules list
    -tree               dispaly modules list with dependences it
    -l, --loc           display location abs path
    -with               using with "loc" option. this option must be "p" or "r" or "m"
    -lib, --library     using with "loc" option or "module" option.
                         this option must be relative path from "main" js
    -p, --package_json  display the contents of package.json
    -r, --readme        dispaly the contents of README.(*)
    -m, --module        dispaly the contents of "main" js

Example:

    nodedoc -l mongoose
    nodedoc -l mongoose -with r              display mongoose's README path
    nodedoc -r mongoose                      display mongoose's README contents
    nodedoc -l mongoose -lib ./lib/index.js  display mongoose's library js

 if you can use "mad".

   nodedoc -r mongoose | mad -               display mongoose's README contents. it is parsed

HELP
;

}
1;

package main;
use strict;
use warnings;

my $app   = MyApp->new;
my $cont  = $app->{controler};
my $model = $app->{model};
my $view  = $app->{view};

$cont->test(qw/help/ => sub { $view->help() });
$cont->test(qw/module library/ => sub {
    my $argv = shift;
    $view->display_contents( $model, $argv->{module}, 'library',
                             $argv->{library});
});
$cont->test(qw/module/ => sub {
    my $argv = shift;
    $view->display_contents( $model, $argv->{module}, 'module');
});
$cont->test(qw/package_json/ => sub {
    my $argv = shift;
    $view->display_contents( $model, $argv->{package_json}, 'package_json');
});
$cont->test(qw/readme/ => sub {
    my $argv = shift;
    $view->display_contents($model, $argv->{readme}, 'readme');
});

$cont->test(qw/loc with/ => sub {
    my $argv = shift;
    my $mod_name = $argv->{loc};
    my %modes = (
        p => 'package_json',
        r => 'readme',
        m => 'module',
    );
    my $mode = $modes{$argv->{with}};
    $view->display_path($model, $mod_name, $mode);
});
$cont->test(qw/loc library/ => sub {
    my $argv = shift;
    $view->display_path($model, $argv->{loc}, 'library', $argv->{library});
});
$cont->test(qw/loc/ => sub {
    my $argv = shift;
    $view->display_path($model, $argv->{loc}, 'module');
});
$cont->test(qw/list/ => sub {
    $view->list( $model, 'list');
});
$cont->test(qw/tree/ => sub {
    $view->list( $model, 'tree');
});

exit 0;

